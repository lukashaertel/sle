/*
 * generated by Xtext
 */
package sle.fsml.validation

import org.eclipse.xtext.validation.Check
import sle.fsml.fSML.FSM
import sle.fsml.fSML.FSMLPackage
import sle.fsml.fSML.FSMState
import sle.fsml.fSML.FSMTransition
import java.util.Set

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class FSMLValidator extends AbstractFSMLValidator
{
	public static val NO_INITIAL_STATE = "noInitialState";

	public static val MORE_THAN_ONE_INITIAL_STATE = "moreThanOneInitialState";

	public static val EXPLICIT_NON_TRANSITION = "explicitNonTransition";

	public static val NON_DETERMINISTIC = "nonDeterministic";

	public static val NOT_REACHABLE = "notReachable";

	@Check
	def checkHasInitialState(FSM fsm)
	{
		val initCount = fsm.states.filter[initial].size

		if(initCount < 1)
		{
			for (s : fsm.states)
			{
				error('FSM has no initial state', s, FSMLPackage.Literals.FSM_STATE__NAME, NO_INITIAL_STATE)
			}
		}
		else if(initCount > 1)
		{
			for (s : fsm.states.filter[initial])
			{
				error('FSM has more than one initial state', s, FSMLPackage.Literals.FSM_STATE__NAME,
					MORE_THAN_ONE_INITIAL_STATE)
			}
		}
	}

	@Check
	def checkSelfTargeting(FSMTransition transition)
	{
		if(transition.target != null && transition.target.equals(transition.eContainer))
		{
			warning('Transition does not change state, target should be omitted', transition,
				FSMLPackage.Literals.FSM_TRANSITION__TARGET, EXPLICIT_NON_TRANSITION);
		}
	}

	@Check
	def checkDeterministic(FSMTransition transition)
	{
		val container = transition.eContainer as FSMState

		if(container.transitions.exists[x|x.input == transition.input && x != transition])
		{
			error('Transition shares input with other transition', transition,
				FSMLPackage.Literals.FSM_TRANSITION__INPUT, NON_DETERMINISTIC);
		}
	}

	def <T> boolean findBF(T initial, (T)=>Iterable<T> next, (T)=>boolean p)
	{
		return findBF(initial, newHashSet, next, p)
	}

	def <T> boolean findBF(T initial, Set<T> visited, (T)=>Iterable<T> next, (T)=>boolean p)
	{
		visited.add(initial)

		if(p.apply(initial))
		{
			return true
		}
		else
		{
			for (n : next.apply(initial).filter[x|!visited.contains(x)])
			{
				if(findBF(n, visited, next, p))
				{
					return true
				}
			}

			return false
		}
	}

	def incomingStates(FSMState s)
	{
		val fsm = s.eContainer as FSM

		return fsm.states.map[transitions].flatten.filter[target == s].map[eContainer as FSMState]
	}

	@Check
	def checkIsReachable(FSMState state)
	{
		if(!state.findBF([x|incomingStates(x)], [x|x.initial]))
		{
			error('State is not reachable from the initial state', state, FSMLPackage.Literals.FSM_STATE__NAME,
				NOT_REACHABLE);
		}
	}
}
