/*
 * generated by Xtext
 */
package sle.fsml.run.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import sle.fsml.run.run.Run
import sle.fsml.run.run.MachineReference
import sle.fsml.run.run.MachineLocation
import sle.fsml.run.run.InputReference
import sle.fsml.run.run.InputLocation
import static extension sle.fsml.run.Resolve.*
import sle.fsml.run.Simulate

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class RunGenerator implements IGenerator
{

	/**
	 * Normalize file path as package name element
	 */
	def toPackage(String n)
	{
		n.replace('.', '_').replace('/', '_').replace('\\', '_')
	}

	/**
	 * Get the first package segment
	 */
	def headPackage(Run run)
	{
		val machine = run.machine
		switch (machine)
		{
			MachineReference: machine.fsm.name
			MachineLocation: machine.location.toPackage
		}
	}

	/**
	 * Get the second package segment
	 */
	def tailPackage(Run run)
	{
		val input = run.input
		switch (input)
		{
			InputReference: input.input.name
			InputLocation: input.location.toPackage
		}
	}

	override void doGenerate(Resource resource, IFileSystemAccess fsa)
	{
		for (Run run : resource.allContents.filter(typeof(Run)).toIterable)
		{
			// Resolve locations to machines and input
			val fsm = run.machine.resolveFSM;
			val input = run.input.resolveInput;

			// Simulate FSM with given machine and input
			val simulation = Simulate::simulate(fsm, input);

			// Save result to target
			fsa.generateFile(run.target,
				'''
					[
					«FOR p : simulation SEPARATOR ','»  («IF p.key == null»[]«ELSE»[«p.key»]«ENDIF», «p.value.name»)
					«ENDFOR»
					].
				''')

//			// Generate Java code
//			val hp = run.headPackage
//			val tp = run.tailPackage
//
//			val stateCN = 'State';
//			val stateFN = 'java/' + hp + '/' + tp + '/' + stateCN + '.java'
//			val statePN = 'java.' + hp + '.' + tp;
//
//			fsa.generateFile(stateFN,
//				'''package «statePN»;
//			public enum «stateCN»
//			{
//				«FOR s : fsm.states SEPARATOR ', '»«s.name»«ENDFOR»
//			}
//			''')
//
//			val inputCN = 'Input';
//			val inputFN = 'java/' + hp + '/' + tp + '/' + inputCN + '.java'
//			val inputPN = 'java.' + hp + '.' + tp;
//
//			fsa.generateFile(inputFN,
//				'''package «inputPN»;
//			public enum «inputCN»
//			{
//				«FOR s : fsm.states.map[s|s.transitions.map[t|t.input]].flatten SEPARATOR ', '»«s»«ENDFOR»
//			}
//			''')
//
//			val actionCN = 'Action';
//			val actionFN = 'java/' + hp + '/' + tp + '/' + actionCN + '.java'
//			val actionPN = 'java.' + hp + '.' + tp;
//
//			fsa.generateFile(actionFN,
//				'''package «actionPN»;
//			public enum «actionCN»
//			{
//				«FOR s : fsm.states.map[s|s.transitions.filter[t|t.withAction].map[t|t.action]].flatten SEPARATOR ', '»«s»«ENDFOR»
//			}
//			''')
		}
	}
}
