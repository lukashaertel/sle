-- @atlcompiler emftvm
-- @nsURI MM=http://www.eclipse.org/gmf/runtime/1.0.2/notation
-- @nsURI MM1=http://www.eclipse.org/uml2/4.0.0/UML


module layout;
create OUT: MM refining IN: MM, UML: MM1;

rule DeleteNode {
	from
		s: MM!Shape (
			(not s.existing) and s.element.oclIsTypeOf(MM1!State)
		)
	to
}

rule UpdateRegion {
	from
		s: MM!DecorationNode (
			s.refImmediateComposite().element.oclIsTypeOf(MM1!Region)
		)
	to
		t: MM!DecorationNode (
			children <- s.children.union(MM1!State.allInstances() -> select(s | not s.
					existing) -> iterate(s; res: Sequence(MM!Shape) = Sequence{} | res.
					append(thisModule.CreateState(s))))
		)
}

rule CreateState(state: MM1!State) {
	to
		shape: MM!Shape (
			fontName <- 'Segoe UI',
			type <- '6000',
			lineColor <- 0,
			eAnnotations <- Sequence{thisModule.CreateEAnnotation('ShadowFigure',
					'ShadowFigure_Value', 'false'),
						thisModule.CreateEAnnotation('displayNameLabelIcon',
								'displayNameLabelIcon_value', 'false'),
						thisModule.CreateEAnnotation('QualifiedName',
								'QualifiedNameDepth', '1000')},
			children <- Sequence{thisModule.CreateDecorationNode(true, 0, 0, 100, 20,'6001'),
						thisModule.CreateDecorationNode(false, 0, 100, 100, 42,'6002')},
			element <- state,
			layoutConstraint <- thisModule.CreateBounds(303, 116, 100, 62)
		)
	do {
		shape; 
	}
}

rule CreateEAnnotation(source: String,key: String, value: String) {
	to
		an: MM!EAnnotation (
			source <- source,
			details <- Sequence{sm}
		),
		sm: MM!EStringToStringMapEntry (
			key <- key,
			value <- value
		)
	do {
		an; 
	}
}

rule CreateDecorationNode(v: Boolean, newX: Integer, newY: Integer, newWidth: Integer,
		newHeight: Integer,newType :String) {
	to
		dn: MM!DecorationNode (
			visible <- v,
			layoutConstraint <- thisModule.CreateBounds(newX, newY, newWidth, newHeight),
			type <- newType
		)
		
	do {
		dn; 
	}
}

rule CreateBounds(newX: Integer, newY: Integer, newWidth: Integer, newHeight: Integer) {
	to
		b: MM!Bounds (
			x <- newX,
			y <- newY,
			width <- newWidth,
			height <- newHeight
		)
	do {
		b; 
	}
}

rule DeleteEAnnotation {
	from
		s: MM!EAnnotation (
			not thisModule.existingContainer(s)
		)
	to
}

rule DeleteDecorationNode {
	from
		s: MM!DecorationNode (
			not thisModule.existingContainer(s)
		)
	to
}

rule DeleteBounds {
	from
		s: MM!Bounds (
			not thisModule.existingContainer(s)
		)
	to
}

rule DeleteEStringToStringMapEntry {
	from
		s: MM!EStringToStringMapEntry (
			not thisModule.existingContainer(s)
		)
	to
}

helper context MM!Shape def: existing: Boolean =
	MM1!State.allInstances() -> exists(s | self.element.debug() = s);

helper context MM1!State def: existing: Boolean =
	MM!Shape.allInstances() -> exists(s | s.element.debug() = self);

helper def: existingContainer(eo: OclAny): Boolean =
	if eo.oclIsTypeOf(MM!Shape) then
		eo.existing or (not eo.element.oclIsTypeOf(MM1!State))
	else
		if eo.refImmediateComposite() = OclUndefined then
			true
		else
			thisModule.existingContainer(eo.refImmediateComposite())
		endif
	endif;
